// 我们可以创建作用域并决定某个名字是否处于该作用于中, 但是不能在同一作用域中使用相同的名字指向两个不同的条目
// 有一些工具可以被用来解决命名冲突。
// Rust 提供了一系列的功能来帮助我们管理代码, 包括决定哪些细节是暴露的、哪些细节是私有的，以及不同作用域内存在哪些名称, 这些功能有时被统称为模块系统
// 他们包括:
//  1. 包 ( package )                : 一个用于构建、测试并分享单元包的 cargo 功能
//  2. 单元包 ( crate )               : 一个用于生成库或可执行文件的树形模块结构
//  3. 模块 ( module ) 及 use 关键字   : 它们被用于控制文件结构、作用域以及路径的私有性
//  4. 路径 ( path )                  : 一种用于条目命名的方法，这些条目包括结构体、函数和模块等

// 单元包
// 单元包可以被用于生成二进制程序或库, 我们将 Rust 编译时所使用的入口文件称做这个单元包的根节点，它同时也是单元包的根模块
//  1. Cargo 默认会将 src/main.rs 视作一个二进制单元包的根节点而无需指定, 这个二进制单元包与包拥有相同的名称
//  2. Cargo 默认会将 src/lib.rs 视作一个库单元包的根节点而无需指定, 这个库单元包与包拥有相同的名称
//  3. Cargo 会在构建库和二进制程序时将这些单元包的根节点文件作为参数传递给 rustc
//  4. 我们可以在路径 src/bin 下添加源文件来创建出更多的二进制单元包, 或这个路径下的每个源文件都会被视作单独的二进制单元包
//  5. 单元包可以将相关的功能分组，并放到同一个作用域下
//  6. 将单元包的功能保留在他们自己的作用域中有助于指明某个特定功能来源于哪个单元包，并避免可能的命名冲突

// 包
// 包由一个或多个提供相关功能的单元包集合而成，它所附带的配置文件 Cargo.toml 描述了如何构建这些单元包的信息
// 几条规则决定了包可以包含哪些内容:
//  1. main.rs 为二进制单元包, lib.rs 为库单元包
//  2. 一个包中只能拥有最多一个库单元包
//  3. 包可以拥有任意多个二进制单元包
//  4. 包内至少存在一个单元包 ( 库单元包或是二进制单元包 )

// 路径 ( Path )
// 为了在 Rust 的模块中找到某个条目，需要使用路径
//
// 路径的 2 种形式
//  1. 绝对路径: 从 crate root 开始, 使用 crate 名，或是字面值 crate
//  2. 绝对路径: 从当前模块开始, 实用 self, super 或当前模块的标识符
// 路径至少由一个标识符组成, 标识符之间使用 ::

// 私有边界 ( privacy boundary )
// 模块不仅可以组织代码，还可以定义私有边界
// 如果想把函数或 struct 等设为私有的, 可以将他们放在某个模块中
// Rust 种的所有条目 ( 函数, 方法, struct, enum, 模块, 常量 ) 等, 默认都是私有的
// 父级别模块无法访问子模块中的私有条目
// 子模块里可以使用所有祖先模块中的条目

pub mod hosting;

pub fn fix_order() {
    println!("fix order");
}