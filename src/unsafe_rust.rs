pub fn learning_unsafe_rust() {
    println!("start to learn unsafe rust");

    // 不安全 Rust
    // 匹配命名变量
    // 隐藏着第二个语言, 它没有强制内存安全保证: unsafe rust ( 不安全的 rust )
    //  - 和普通 rust 一样, 但提供了额外的超能力

    // unsafe rust 存在的原因
    //  - 静态分析是保守的
    //    - 使用 unsafe rust: 我知道自己在做什么, 并承担相应的风险
    //  计算机硬件本身就是不安全的, rust 需要能够进行底层系统编程

    // unsafe 超能力
    // 使用 unsafe 关键字切换到 unsafe rust, 开启一个块, 里面放着 unsafe 代码
    // unsafe rust 里可执行的四个动作 ( unsafe 超能力 )
    //  - 解引用原始指针
    //  - 调用 unsafe 函数或方法
    //  - 访问或修改可变的静态变量
    //  - 实现 unsafe trait

    // 注意:
    // unsafe 并没有关闭借用检查或停用其他安全检查
    // 任何内存安全的错误必须停留在 unsafe 块里
    // 尽可能隔离 unsafe 代码, 最好将其封装在安全的抽象里, 提供安全的 API

    // 解引用原始指针 ( raw pointer )
    // 原始指针
    //  - 可变的: *mut T
    //  - 不可变的: *const T  意味着指针在解引用后不能直接对其进行赋值
    //  - 这里的 * 不是解引用符号, 它是类型名的一部分

    // 与引用不同, 原始指针:
    //  - 我们先来复习一下借用规则: 多个指向同一个区域的可变引用会导致数据的竞争，以及数据的不一致
    //  - 借用规则: 在任何给定的时间, 你要么只能拥有一个可变引用, 要么只能拥有任意数量的不可变引用
    //  - 允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针来忽略借用规则
    //  - 无法保证能指向合理的内存
    //  - 允许为 null
    //  - 不实现任何的自动清理
    // 放弃保证的安全, 换取更好的性能 / 与其他语言或硬件接口的能力

    // 我们可以在不安全代码块之外创建原始指针, 但是只能在不安全代码块里面对其进行解引用
    let mut num = 5;

    // 我们分别将不可变和可变引用转变成了原始指针 *const 和 *mut , 因为这 2 个指针是来自有效的引用
    // 所以我们知道这 2 个指针也是有效的
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    // 原始指针并不一直都是有效的, 下面我们创建一个无法确定其有效性的原始指针
    let address = 0x012345usize;
    let r = address as *const i32;

    // 解引用原始指针
    unsafe {
        println!("r1: {}", *r1);
        println!("r2: {}", *r2);
    }

    // r1 和 r2 指向了同一块内存地址, 此时我们可以通过可变引用 r2 来修改其里面的值
    // 这种操作是允许的, 但是需要格外小心
    unsafe {
        *r2 = 10000;
        println!("updated r2: {}", *r2);
        println!("updated r1: {}", *r1);
    }
}