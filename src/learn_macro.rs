pub fn learning_macros() {
    println!("Start to learn macros");

    // 宏 macro
    // 宏在 Rust 里指的是一组相关特性的集合称谓:
    //  - 使用 macro_rules! 构建的声明宏 ( declarative macro )
    //  - 3 种过程宏
    //    - 自定义 #[derive] 宏, 用于 struct 或 enum, 可以为其指定随 derive 属性添加的代码
    //    - 类似属性的宏, 在任何条目上添加自定义属性
    //    - 类似函数的宏, 看起来像函数调用, 对其指定为参数的 token 进行操作

    // 函数与宏的差别
    // 本质上, 宏是用来编写可以生成其他代码的代码 ( 元编程, meta programming )
    // 函数在定义签名时, 必须声明参数的类型和个数, 宏可处理可变的参数
    // 编译器会在解释代码前展开宏
    // 宏的定义比函数复杂的多, 难以阅读、理解、维护
    // 在某个文件调用宏时, 必须提前定义宏或将宏引入当前作用域
    // 函数可以在任何位置定义并在任何位置使用

    // macro_rules! 声明宏 ( 弃用 )
    // Rust 中最常见的宏模式: 声明宏
    //  - 类似 match 的模式匹配
    //  - 需要使用 marco_rules!

    // 基于属性来生成代码的过程宏
    // 这种形式更像函数 ( 某种形式的过程 ) 一些
    //  - 接收并操作输入的 Rust 代码
    //  - 生成另外一些 Rust 代码作为结果
    // 三种过程宏
    //  - 自定义派生
    //  - 属性宏
    //  - 函数宏
    // 创建过程宏
    //  - 宏定义必须单独放在它们自己的包中, 并使用特殊的包类型
}