pub fn learning_threads() {
    println!("Start to learn threads 3");

    // 共享状态的并发 ( 使用共享来实现并发 )
    // Go 语言的名言: 不要用共享内存来通信, 要用通信来共享内存
    // Rust 支持通过共享状态来实现并发
    // Channel 类似单所有权: 一旦将值的所有权转移至 Channel, 就无法使用它了
    // 共享内存并发类似多所有权: 多个线程可以同时访问同一块内存

    // 使用 Mutex 来每次只允许一个线程来访问数据
    // Mutex 是 mutual exclusion ( 互斥锁 ) 的缩写
    // 在同一时刻, Mutex 只允许一个线程来访问某些数据
    // 想要访问数据:
    //  - 线程必须先获取互斥锁 ( lock )
    //  - lock 数据结构式 mutex 的一部分, 它能跟踪谁对数据拥有独占访问权
    // mutex 通常被描述为: 通过锁定系统来保护它所持有的数据

    // Mutex 的两条规则
    // 在使用数据之前, 必须尝试获取锁 ( lock )
    // 使用完 mutex 所保护的数据, 必须对数据进行解锁, 以便其他线程可以获取锁
}