pub fn learning_smart_pointer() {
    println!("Start to learn smart pointer");

    // 章节: 智能指针

    // 指针: 一个变量在内存中包含的是一个地址 ( 指向其他数据 )
    // Rust 中最常见的指针就是 "引用"
    // 引用:
    //  - 使用 &
    //  - 借用它指向的值
    //  - 没有其余开销
    //  - 最常见的指针类型

    // 智能指针
    // 智能指针是这样的一些数据结构:
    //  - 行为和指针相似
    //  - 有额外的元数据和功能

    // 引用技术 ( reference counting )
    // 通过记录所有者的数量，使一份数据被多个所有者同时持有
    // 并在没有任何所有者时候自动清理数据

    // 引用和智能指针的其他不同
    // 引用: 只借用数据
    // 智能指针: 很多时候拥有它所指向的数据

    // 智能指针的例子
    // String 和 Vec<T>
    //  - 都拥有一片内存区域, 且允许用户对其操作
    //  - 还拥有元数据 ( 例如容量等 )
    //  - 提供额外的功能或保障 ( String 保障其数据类型是合法的 UTF-8 编码 )

    // 智能指针的实现
    // 智能指针通常使用 struct 实现，并且实现了:
    //  - Deref 和 Drop 这两个 Trait
    // Deref trait: 允许智能指针 struct 的实例像引用一样使用
    // Drop trait: 允许你自定义放智能指针实例走出作用域时的代码

    // 标准库中常见的智能指针
    //  - Box<T>: 在 heap 内存上分配值
    //  - Rc<T>: 启用多重所有权的引用计数类型
    //  - Ref<T> 和 RefMut<T>, 通过 RefCell<T> 访问: 在运行时而不是编译时强制借用规则的类型
    // 此外:
    //  - 内部可变模式 ( interior mutability pattern ): 不可变类型暴露出可修改其内部值的 API
    //  - 引用循环 ( reference cycles ): 他们如何泄露内存，以及如何防止其发生
}
